<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ECC Brute Force Visualization</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background-color: #0d1117;
      color: #00ff00;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 1px solid #333;
      position: relative;
      box-shadow: 0 0 20px #00ff00;
    }
    .problem-statement {
      font-size: 14px;
      margin-bottom: 20px;
      text-align: left;
      width: 90%;
      line-height: 1.5;
    }
    .problem-statement b {
      color: #ff6600;
    }
    .password-cracking-panel {
      width: 80%;
      background-color: #1e1e2f;
      color: #00ff00;
      padding: 10px;
      margin-top: 20px;
      border: 1px solid #333;
      border-radius: 5px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      overflow: hidden;
      text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
    }
    #cracking-animation {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <div class="problem-statement">
    <b>Elliptic Curve Domain Parameters (secp256k1):</b><br><br>
    <b>Finite Field:</b> \( F_p \), where <br>
    <code>
      p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F<br>
        = 2<sup>256</sup> - 2<sup>32</sup> - 2<sup>9</sup> - 2<sup>8</sup> - 2<sup>7</sup> - 2<sup>6</sup> - 2<sup>4</sup> - 1
    </code><br><br>
    <b>Curve Equation:</b> \( E: y^2 = x^3 + ax + b \), where <br>
    <code>
      a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000<br>
      b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007
    </code><br><br>
    <b>Base Point \( G \):</b><br>
    Compressed Form:<br>
    <code>
      G = 02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798
    </code><br>
    Uncompressed Form:<br>
    <code>
      G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798<br>
          483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8
    </code><br><br>
    <b>Order \( n \) of \( G \):</b><br>
    <code>
      n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141
    </code><br><br>
    <b>Cofactor \( h \):</b><br>
    <code>h = 1</code><br><br>
    <b>Target Public Key \( Q \):</b><br>
    <code id="public-key"></code><br>
    <b>Attempting to find the private key \( k \).</b>
  </div>
  <canvas id="curve-canvas" width="800" height="400"></canvas>
  <div class="password-cracking-panel">
    <div id="cracking-animation"></div>
  </div>

<script>
function startEllipticCurveCrackingAnimation() {
  const animationElement = document.getElementById('cracking-animation');
  const publicKeyElement = document.getElementById('public-key');
  const canvas = document.getElementById('curve-canvas');
  const ctx = canvas.getContext('2d');

  // ECC parameters
  const a = 0; // Coefficient for x
  const b = 7; // Constant
  const scale = 10; // Scale factor for visual clarity
  const width = canvas.width;
  const height = canvas.height;

  const basePoint = { x: 2, y: 5 }; // Base point G
  const prime = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F"); // Secp256k1 prime modulus
  const two256 = BigInt(2) ** BigInt(256); // 2^256
  const correctKey = two256 - BigInt(Math.floor(Math.random() * 1000000)); // Simulated 256-bit private key
  const publicKey = calculatePoint(correctKey); // Target public key Q

  let currentKey = two256; // Start brute force from 2^256
  const pathPoints = []; // Track all attempted points

  // Display the public key
  publicKeyElement.textContent = `(${publicKey.x.toString()}, ${publicKey.y.toString()})`;

  // Simulate modular arithmetic to calculate kG
  function calculatePoint(k) {
    return {
      x: (BigInt(basePoint.x) * k) % prime,
      y: (BigInt(basePoint.y) * k) % prime,
    };
  }

  // Draw the grid
  function drawGrid() {
    ctx.strokeStyle = '#003300'; // Dark green grid
    ctx.lineWidth = 0.5;
    for (let x = 0; x < width; x += 20) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    for (let y = 0; y < height; y += 20) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
  }

  // Draw the elliptic curve
  function drawEllipticCurve() {
    ctx.clearRect(0, 0, width, height);
    drawGrid();
    ctx.strokeStyle = '#00ff00'; // Bright green curve
    ctx.lineWidth = 2; // Thicker line for better visibility
    ctx.beginPath();
    for (let x = -width / (2 * scale); x <= width / (2 * scale); x += 0.1) {
      const ySquared = x ** 3 + a * x + b;
      if (ySquared >= 0) {
        const y1 = Math.sqrt(ySquared);
        const y2 = -Math.sqrt(ySquared);
        ctx.fillRect(scale * x + width / 2, -scale * y1 + height / 2, 2, 2);
        ctx.fillRect(scale * x + width / 2, -scale * y2 + height / 2, 2, 2);
      }
    }
    ctx.stroke();
  }

  // Draw points
  function drawPoint(point, color, label) {
    if (!point) return; // Avoid invalid points
    ctx.beginPath();
    ctx.arc(
      scale * Number(point.x) + width / 2,
      -scale * Number(point.y) + height / 2,
      5,
      0,
      2 * Math.PI
    );
    ctx.fillStyle = color;
    ctx.fill();
    if (label) {
      ctx.fillStyle = '#00ff00'; // Label color
      ctx.font = '12px Courier New';
      ctx.fillText(label, scale * Number(point.x) + width / 2 + 8, -scale * Number(point.y) + height / 2 - 8);
    }
  }

  // Draw connection lines between points
  function drawConnection(from, to) {
    ctx.beginPath();
    ctx.moveTo(
      scale * Number(from.x) + width / 2,
      -scale * Number(from.y) + height / 2
    );
    ctx.lineTo(
      scale * Number(to.x) + width / 2,
      -scale * Number(to.y) + height / 2
    );
    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)'; // Semi-transparent yellow
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // Animation loop
  const crackingInterval = setInterval(() => {
    if (currentKey <= correctKey) {
      clearInterval(crackingInterval);
      animationElement.textContent = `[+] Key Found: k = ${correctKey.toString(16)}`;
      drawPoint(publicKey, '#ff0000', 'Q'); // Highlight the public key
      return;
    }

    currentKey--; // Decrement key
    const kG = calculatePoint(currentKey);

    pathPoints.push(kG); // Store path
    drawEllipticCurve(); // Redraw the curve
    drawPoint(basePoint, '#0000ff', 'G'); // Draw base point
    drawPoint(publicKey, '#ff0000', 'Q'); // Draw public key

    // Draw all connections
    for (let i = 0; i < pathPoints.length; i++) {
      drawConnection(basePoint, pathPoints[i]); // Connect G to each kG
    }

    // Highlight the current attempt
    drawPoint(kG, '#ffff00', `kG`); // Highlight current kG

    animationElement.textContent = `Trying k = ${currentKey.toString(16)}, kG = (${kG.x.toString(16)}, ${kG.y.toString(16)})`;
  }, 10); // Milliseconds between iterations

  drawEllipticCurve(); // Initial draw
}

// Start the animation
document.addEventListener('DOMContentLoaded', () => {
  startEllipticCurveCrackingAnimation();
});
</script>


</body>
</html>
